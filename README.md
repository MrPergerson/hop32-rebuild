# HOP32
Created by Sietch of Ludicrous <br>
Game design and development: Cole Pergerson<br>
Production, outreach, and character design: James Morgan<br>
Additional development: Shahbaz Mansahia<br>

## Player input
Our original plan for 32 players on the keyboard was quite unconventional and we weren't sure if this was possible in Pico8. We did consider hacking gamepad input
in such a way where each button represented a unique player, but luckily we found that Pico8 had experiemental support for full keyboard and mouse input. See 
6.13 in the manual for the details. At the start of the game, players can press any key and a character becomes assigned to that key. When physical buttons were introduced,
the keys were changed to be preassigned so that players would know which character they would play when they chose a button. The predetermined key assignemnts or assigning keys "at will" methods were both useful and a setting to switch between the two is planned. 

## Characters
A character is just a table that holds the essential data such as location, sprite, score, and other variables. Look in players.lua for the full table. When players are in the 
game and press their button, the jump function is called. Pressing rapidly performs short hops while pressing in longer intervals performs higher hops. The jump strength increases exponentially over time when the player is on the ground and resets when the button is pressed. 

## Level generation
The environment is procedurally generated in chunks to reduce memory costs. The method is fairly trivial; first fill all the grid spaces with tiles, then 
remove tiles above a height determined by a sin wave. The sin wave can be modified to allow for different terrain types, such as grass lands, desert dunes, or mountains. To change the sprite of the terrain, so they look visually different, I had a simple distance check for each biome. The terrain doesn't change per playthrough. The only thing that does change is where holes and zombies are generated. Holes are generated by choosing a tile every X distance, then clearing out a specified width of tiles. Zombies are spawned the same way, except certain surface tiles are choosen as spawn points. 

## Collisions
There are two types of collisions; terrain and object collisions. Since the map feature wasn't being used, a custom collision system was needed for terrain collisions that was fast
and cheap. When checking terrain collisions, all the coordinates are converted from world to normalized grid values. Then objects are tested to determine if they overlap with any 
terrain cells, and if they are, snap them to the nearest empty cell. This method only works if all collision objects are are the same size. For object collisions, only characters (which are consider as objects) can collide with other objects. Each character runs a for loop for each possible object collision and checks for all active objects for overlap. 

## Respawn Birds
These are the abstract characteres that fly across the screen holding characters who had perished. These were originally inspired by the story that storks deliver babies, hence why the file is called "respawn birds." In later updates, it will be updated to a helicopter. When a player dies, they get added to a respawn queue where they wait their turn
to be respawned. The respawn interval decreases as more players are added. When a player respawns, they are removed from the queue and are flown across the screen. If a player
collides with the bird, the respawned player is enabled and dropped into the world, otherwise they get returned to the end of the queue. 

## Main loop
The only section of the code that has surivived numeruous refactors since the game jam is the main loop in main.lua. It's a mess and difficult to fully understand, but it works, hence why it was barely touched. Although this did come with some consequences, such as player.lua having to take on some of the game loop. Any changes to how the game starts and ends, and how players join require some sort of hack. 
